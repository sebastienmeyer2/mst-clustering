#include "graph.hpp"

Graph::Graph(){
    this->node_counter = 0;
    this->edge_counter = 0;
}


void build_from_ashiip(Graph* g, std::string file_path)
{
    /*!
     * @brief Builds a graph from scratch, from the nodes and edges generated by 
     * aSHIIP and contained in a specific file format. Adds a random weight drawn 
     * by an exponential distribution to each edge.
     * 
     * @param file_path The path to the file 
     * 
     */

    std::ifstream is(file_path);
    assert(("No such file", is.is_open()));

    std::unordered_map<node_label_t, Node*> created_nodes;
    std::unordered_map<Node*, std::unordered_set<Node*> > links;

    std::default_random_engine generator;
    std::exponential_distribution<double> distribution(1);

    std::string line;

    while (std::getline(is, line)) {

        std::istringstream iss(line);

        // node's label (here, we want positive integers)
        node_label_t label;
        iss >> label;

        if (label <= 0) {
            continue;
        }

        Node* n_in;
        if (created_nodes.find(label) == created_nodes.end()) {
            n_in = new Node(label);
            created_nodes.insert(std::pair<node_label_t, Node*>(label, n_in));
        } else {
            n_in = created_nodes.at(label);
        }

        // type of node (not useful here)
        std::string cat;
        iss >> cat;

        // edges
        std::string other_node;
        int j = 0;
        while (iss >> other_node) {

            if (j == 0) {
                other_node = other_node.substr(1); // eliminating bracket
            }

            int length = other_node.size();
            other_node = other_node.substr(0, length-1); // eliminating comma
            node_label_t other_label = stoi(other_node);

            Node* n_out;
            if (created_nodes.find(other_label) == created_nodes.end()) {
                n_out = new Node(other_label);
                created_nodes.insert(std::pair<node_label_t, Node*>(other_label, n_out));
            } else {
                n_out = created_nodes.at(other_label);
            }

            // avoid double insertion of same edges
            Node* master_node = (n_in->label > n_out->label) ? n_in : n_out;
            Node* slave_node = (master_node == n_in) ? n_out : n_in;

            bool force_insert = false;

            if (links.find(master_node) == links.end()) {
                links.insert(std::pair<Node*, std::unordered_set<Node*> >(master_node, std::unordered_set<Node*>()));
                force_insert = true;
            }

            std::unordered_set<Node*>& linked_nodes = links.at(master_node);
            if (linked_nodes.find(slave_node) == linked_nodes.end()) {
                linked_nodes.insert(slave_node);
                force_insert = true;
            }

            if (force_insert == true) {
                Edge* e = new Edge(n_in, n_out, distribution(generator));
                g->add_edge(e);
            }

            j += 1;
        }
    }
}

Graph::Graph(std::string file_path) : Graph()
{
    /*!
     * @brief Builds a graph from scratch, with its nodes and edges contained in a file
     * 
     * @param file_path The path to the file 
     * 
     */
    build_from_ashiip(this, file_path);
}

Graph::Graph(std::vector<Point*> points)
{
    /*!
     * @brief Builds a graph from scratch, with its nodes being points of a certain dimension
     * 
     * @param points A vector of points in memory 
     * 
     */

    int n = points.size();
    std::vector<Node*> nodes;

    for (int i = 0; i < n; i ++) {
        nodes.push_back(new Node(i, points[i]));
        this->add_node(nodes[i]);
    }

    for (int i = 0; i < n; i ++) {
        for (int j = i+1; j < n; j ++) {
            this->add_edge(new Edge(nodes[i], nodes[j]));
        }
    }
}

bool Graph::has_node(Node* n){
    /*!
     * @brief Vérifie si le noeud \p n est suvi par le graphe
     * 
     * @param n Le noeud
     * 
     * @return true si le noeud \p n appartient bien au graphe, false sinon
     * 
     */

    return this->adjacency_lists.find(n) != this->adjacency_lists.end();
}

void Graph::add_node(Node* n){
    /*!
     * @brief Ajoute le noeud \p n au graphe
     * 
     * @param n Le noeud
     * 
     */


    if(this->has_node(n))
        return;

    this->adjacency_lists.insert(
        std::pair<Node*, std::unordered_set<Edge*> >(
                                                        n,
                                                        std::unordered_set<Edge*>()
                                                    )
                                );
    
    n->set_id(this->node_counter);
    this->node_id_mapper.insert(std::pair<node_id_t, Node*>(this->node_counter++, n));

    
    
}


void Graph::add_edge(Edge* e){
    /*!
     * @brief Ajoute l'arrête \p e au graphe
     * 
     * @param e L'arrête
     * 
     * @note Il n'est pas nécessaire d'ajouter les points de \p e au graphe; si ces derniers
     * n'est font pas déjà partie, ils seront ajoutés automatiquement.
     * 
     */

    this->add_node(e->p1);
    this->add_node(e->p2);

    std::unordered_set<Edge*>& adj_p1 = this->adjacency_lists.at(e->p1);
    adj_p1.insert(e);

    std::unordered_set<Edge*>& adj_p2 = this->adjacency_lists.at(e->p2);
    adj_p2.insert(e);

    this->all_edges.insert(e);

    e->id = this->edge_counter;
    this->edge_id_mapper.insert(std::pair<edge_id_t, Edge*>(this->edge_counter++, e));

}



const std::unordered_set<Edge*>& Graph::connected_edges(Node* n){
    /*!
     * @brief Liste les arrêtes entrantes/sortantes de \p n
     * 
     * @param n Le noeud dont on veut connaître les arrêtes liées
     * 
     * @return Un ensemble en lecture seule des arrêtes liées à \p n
     * 
     */

    return this->adjacency_lists.at(n);
}

int Graph::get_number_of_nodes() 
{
    /*!
     * @brief Renvoie le nombre total de noeuds du graphe
     * 
     * @return Nombre de noeuds dans le graphe
     * 
     */

    return this->adjacency_lists.size();
}

std::vector<Node*> Graph::get_nodes()
{
    /*!
     * @brief Renvoie tous les noeuds du graphe (pointeurs)
     * 
     * @return Un vecteur avec les noeuds du graphe
     * 
     */

    std::vector<Node*> nodes;
    for (auto kv : this->adjacency_lists) {
        nodes.push_back(kv.first);
    }

    return nodes;
}

int Graph::get_number_of_edges()
{
    /*!
     * @brief Renvoie le nombre total de noeuds du graphe
     * 
     * @return Nombre de noeuds dans le graphe
     * 
     */

    return this->all_edges.size();
}

std::unordered_set<Edge*> Graph::get_edges()
{
    /*!
     * @brief Renvoie toutes les arêtes du graphe (pointeurs)
     * 
     * @return Un set non classé avec toutes les arêtes du graphe
     * 
     */

    return this->all_edges;
}

Node* Graph::get_any_node()
{
    /*!
     * @brief Renvoie un sommet au hasard dans les sommets du graphe
     * 
     * @return Un noeud au hasard
     * 
     */

    std::vector<Node*> nodes = this->get_nodes();
    int n = this->get_number_of_nodes();

    std::random_device rd; 
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> distrib(0, n-1);

    int idx = distrib(gen);

    return nodes[idx];
}

double Graph::total_weight()
{
    /*!
     * @brief Returns the total weight of the edges of this graph
     * 
     * @return Weight of all edges (by unique identifier)
     * 
     */

    double weight = 0.0;
    for (Edge* e : this->all_edges) {
        weight += e->weight;
    }
    return weight;
}

Node* Graph::get_node(node_id_t id){
    /*!
     * @brief Returns the node whose id matches \p id
     *
     * @param id The id of the node
     * 
     * @returns The node matching \p id
     */


    return this->node_id_mapper.at(id); 
}

Edge* Graph::get_edge(edge_id_t id){
    /*!
     * @brief Returns the edge whose id matches \p id
     *
     * @param id The id of the edge
     * 
     * @returns The edge matching \p id
     */

    return this->edge_id_mapper.at(id);
}